
use crate::board::Board;
use crate::movegen::legal_moves;
use crate::types::{Move, Side, PieceKind};
use crate::tt::{TT, Entry, Bound};
use crate::params::PARAMS;
use parking_lot::Mutex;
use std::sync::Arc;
use std::time::{Instant, Duration};

const MAX_PLY: usize = 128;

#[inline]
fn is_draw(history: &[u64], key: u64, halfmove: u32) -> bool {
    if halfmove >= 100 { return true; } // 50-move rule
    let mut cnt = 0;
    for &k in history.iter().rev() {
        if k == key { cnt += 1; if cnt >= 3 { return true; } }
    }
    false
}


pub struct Search {
    pub nodes: u64,
    pub tt: Arc<Mutex<TT>>,
    pub stop: bool,
    pub threads: usize,
    pub deadline: Option<Instant>,

    // Move ordering
    pub killers: [[Move; 2]; MAX_PLY],      // two killer moves per ply
    pub history: [[i32; 4096]; 2],          // side, from*64+to
}

impl Search {
    pub fn new() -> Self {
        Self {
            nodes: 0,
            tt: Arc::new(Mutex::new(TT::new(64))),
            stop: false,
            threads: 1,
            deadline: None,
            killers: [[Move::default(); 2]; MAX_PLY],
            history: [[0; 4096]; 2],
        }
    }
    pub fn set_hash_mb(&mut self, mb: usize) { *self.tt.lock() = TT::new(mb); }
    pub fn set_threads(&mut self, n: usize) { self.threads = n.max(1); }
pub fn bestmove(&mut self, b:&mut Board, depth: i32) -> Move {
    let mut history_keys: Vec<u64> = vec![b.key];
    self.nodes = 0;
    self.stop = false;
    self.deadline = None;
    let mut best = Move::default();
    let mut last_score: i16 = 0;

    for d in 1..=depth {
        let (m, sc) = self.search_root(b, d, &mut history_keys, last_score);
        if self.stop { break; }
        last_score = sc;
        if m.from != 0 || m.to != 0 { best = m; }
    }
    best

// Time-limited root driver
pub fn bestmove_time(&mut self, b:&mut Board, time_ms: u128) -> Move {
    let mut history_keys: Vec<u64> = vec![b.key];
    self.nodes = 0;
    self.stop = false;
    self.deadline = Some(Instant::now() + Duration::from_millis(time_ms as u64));
    let mut best = Move::default();
    let mut last_score: i16 = 0;

    for d in 1..=64 {
        let (m, sc) = self.search_root(b, d, &mut history_keys, last_score);
        last_score = sc;
        if m.from != 0 || m.to != 0 { best = m; }
        if self.time_up() { self.stop = true; break; }
    }
    best
}

// Root search with aspiration windows
fn search_root(&mut self, b:&mut Board, depth: i32, history_keys: &mut Vec<u64>, prev_score: i16) -> (Move,i16) {
    let moves = legal_moves(b);
    if moves.is_empty() { return (Move::default(), 0); }
    let mut scored = self.score_moves(b, &moves, 0, None);
    scored.sort_by_key(|(s, _)| -*s);

    let mut best = Move::default();
    let mut alpha = prev_score.saturating_sub(50);
    let mut beta  = prev_score.saturating_add(50);
    let (orig_a, orig_b) = (alpha, beta);

    let mut widened_low = false; // will fix to lowercase later
    'asp: loop {
        for (_, mv) in scored.clone() {
            if self.time_up() { self.stop = true; break; }
            let u = b.make_move(mv);
            let is_capture = b.piece_at(mv.to).is_some();
            let mut new_depth = depth - 1;

            // Check extension
            let gave_check = b.in_check(b.stm);
            if gave_check { new_depth += 1; }

            // Basic LMR hook (optional): skip for now or reduce quiets late
            if depth >= 3 && !is_capture && !gave_check { /* optional LMR */ }

            let sc = -self.alphabeta(b, new_depth, -beta, -alpha, 1, false, history_keys);
            b.unmake_move(mv, u);
            if sc > alpha { alpha = sc; best = mv; }
        }

        if alpha <= orig_a && !widened_low {
            alpha = i16::MIN/4; beta = orig_b; widened_low = true; continue 'asp;
        }
        if alpha >= orig_b {
            alpha = orig_a; beta = i16::MAX/4; continue 'asp;
        }
        break;
    }
    (best, alpha)
}
fn alphabeta(&mut self, b:&mut Board, depth: i32, mut alpha: i16, beta: i16, ply: usize, in_null: bool, history_keys: &mut Vec<u64>) -> i16 {
        self.nodes += 1;
        if (self.nodes & 0x1FFF) == 0 && self.time_up() { self.stop = true; return alpha; }
        if is_draw(history_keys, b.key, b.halfmove) { return 0; }
        if is_draw(history_keys, b.key, b.halfmove) { return 0; }
        if is_draw(history_keys, b.key, b.halfmove) { return 0; }
        if depth <= 0 {
            return self.qsearch(b, alpha, beta, history_keys);
        }

        // Mate/stalemate
        let moves = legal_moves(b);
        if moves.is_empty() {
            if b.in_check(b.stm) { return -30000 + ply as i16; } else { return 0; }
        }

        // Null-move pruning
        if !in_null && depth >= 3 && !b.in_check(b.stm) && has_non_pawn_material(b, b.stm) {
            let saved_stm = b.stm;
            // make a null move: just switch side to move and toggle Zobrist
            b.key ^= b.zob.stm;
            b.stm = b.stm.flip();
            let r = 2; // reduction
            let score = -self.alphabeta(b, depth-1-r, -beta, -beta+1, ply+1, true, history_keys);
            // undo "null"
            b.stm = saved_stm;
            b.key ^= b.zob.stm;
            if score >= beta { return score; }
        }

        // TT probe
        let mut tt_best: Option<Move> = None;
        if let Some(e) = self.tt.lock().probe(b.key) {
            tt_best = Some(e.best);
            match e.bound {
                Bound::Exact => return e.value,
                Bound::Lower => { if e.value > alpha { alpha = e.value; } },
                Bound::Upper => { if e.value < beta { return e.value; } },
            }
        }

        // Order moves
        let mut scored = self.score_moves(b, &moves, ply, tt_best);
        scored.sort_by_key(|(s, _)| -*s);

        let mut value = i16::MIN/2;
        let mut best = Move::default();
        let mut alpha = prev_score.saturating_sub(50);
        let mut beta = prev_score.saturating_add(50);
        let original_alpha = alpha; let original_beta = beta;
        for (idx, (_, mv)) in scored.into_iter().enumerate() {
            let u = b.make_move(mv);
            // Late move reduction for quiet moves after a few tries
            let is_capture = b.piece_at(mv.to).is_some();
            let mut new_depth = depth - 1;
            if depth >= 3 && !is_capture && idx >= 4 {
                new_depth -= 1;
            }
            let sc = -self.alphabeta(b, new_depth, -beta, -alpha, ply+1, false, history_keys);
            b.unmake_move(mv, u);
            if sc > value { value = sc; best = mv; }
            if value > alpha { alpha = value; }
            if alpha >= beta {
                // update killers/history on quiet move
                if !is_capture {
                    // killers
                    if self.killers[ply][0].from != mv.from || self.killers[ply][0].to != mv.to {
                        self.killers[ply][1] = self.killers[ply][0];
                        self.killers[ply][0] = mv;
                    }
                    // history
                    let side_idx = if matches!(b.stm, Side::White) {1} else {0}; // note: stm was flipped already; use opponent index
                    self.history[side_idx][mv.from as usize][mv.to as usize] += depth as i32 * depth as i32;
                }
                break;
            }
            if (self.nodes & 0x1FFF) == 0 && self.time_up() { self.stop = true; break; }
        }

        // store TT
        let bound = if value <= alpha { Bound::Upper }
                    else if value >= beta { Bound::Lower }
                    else { Bound::Exact };
        self.tt.lock().store(Entry { key: b.key, depth: depth as i8, value, best, bound });
        value
    }

    fn qsearch(&mut self, b:&mut Board, mut alpha:i16, beta:i16, history_keys:&mut Vec<u64>) -> i16 {
        if (self.nodes & 0x1FFF) == 0 && self.time_up() { self.stop = true; return alpha; }
        if is_draw(history_keys, b.key, b.halfmove) { return 0; }
        let stand = eval(b);
        if stand >= beta { return beta; }
        if stand > alpha { alpha = stand; }

        // Only try captures (and promotions implicitly captured as captures in scoring)
        let moves = legal_moves(b);
        let mut captures: Vec<(i32, Move)> = Vec::new();
        for mv in moves {
            if b.piece_at(mv.to).is_some() {
                if see(b, mv.from, mv.to) < 0 { continue; }
                captures.push((score_capture(b, mv), mv));
            }
        }
        captures.sort_by_key(|(s, _)| -*s);

        for (_, mv) in captures {
            let u = b.make_move(mv);
            let score = -self.qsearch(b, -beta, -alpha, history_keys);
            b.unmake_move(mv, u);
            if score >= beta { return beta; }
            if score > alpha { alpha = score; }
            if (self.nodes & 0x1FFF) == 0 && self.time_up() { self.stop = true; break; }
        }
        let mut tried = 0;
        let mut checks: Vec<Move> = Vec::new(); // collected earlier in this scope
        for mv in checks {
            if tried >= 4 { break; }
            tried += 1;
            let u = b.make_move(mv);
            let score = -self.qsearch(b, -beta, -alpha, history_keys);
            b.unmake_move(mv, u);
            if score >= beta { return beta; }
            if score > alpha { alpha = score; }
            if (self.nodes & 0x1FFF) == 0 && self.time_up() { self.stop = true; break; }
        }
        alpha
    }
    fn score_moves(&self, b:&Board, moves:&[Move], ply: usize, tt_move: Option<Move>) -> Vec<(i32, Move)> {
        let mut v: Vec<(i32, Move)> = Vec::with_capacity(moves.len());
        for &mv in moves {
            let mut s: i32 = 0;
            if let Some(tmv) = tt_move {
                if tmv.from==mv.from && tmv.to==mv.to && tmv.promo==mv.promo {
                    s += 1_000_000;
                }
            }
            if b.piece_at(mv.to).is_some() {
                if see(b, mv.from, mv.to) < 0 { continue; }
                s += score_capture(b, mv);
            } else {
                let side_idx = if b.stm==Side::White {0} else {1};
                // killers
                if self.killers[ply][0].from==mv.from && self.killers[ply][0].to==mv.to { s += 12_000; }
                if self.killers[ply][1].from==mv.from && self.killers[ply][1].to==mv.to { s += 8_000; }
                // history
                let idx = (mv.from as usize)*64 + (mv.to as usize);
                s += self.history[side_idx][idx];
            }
            v.push((s, mv));
        }
        v
    }

fn score_capture(b:&Board, mv: Move) -> i32 {
    let victim = b.piece_at(mv.to).unwrap(); // caller ensures capture
    let att = b.piece_at(mv.from).unwrap();
    let val = |k: PieceKind| -> i32 {
        match k {
            PieceKind::Pawn=>100, PieceKind::Knight=>320, PieceKind::Bishop=>330,
            PieceKind::Rook=>500, PieceKind::Queen=>900, PieceKind::King=>10000,
        }
    };
    val(victim.kind) * 16 - val(att.kind)
}
}


// Check if side has non-pawn material (for null-move safety)
fn has_non_pawn_material(b: &Board, side: Side) -> bool {
    for i in 0..64u8 {
        if let Some(p)=b.piece_at(i) {
            if p.side==side && !matches!(p.kind, PieceKind::Pawn | PieceKind::King) { return true; }
        }
    }
    false
}

// Separate thread-safe depth-only search used by parallel root (not timed)
#[allow(dead_code)]
fn alphabeta_mt(b:&Board, depth: i32, mut alpha: i16, beta: i16, tt: Arc<Mutex<TT>>) -> i16 {
    if is_draw(history_keys, b.key, b.halfmove) { return 0; }
        if is_draw(history_keys, b.key, b.halfmove) { return 0; }
        if depth <= 0 { return qsearch_mt(b, alpha, beta, tt); }

    if let Some(e) = tt.lock().probe(b.key) {
        match e.bound {
            Bound::Exact => return e.value,
            Bound::Lower => { if e.value > alpha { alpha = e.value; } },
            Bound::Upper => { if e.value < beta { return e.value; } },
        }
    }

    let moves = legal_moves(b);
    if moves.is_empty() {
        if b.in_check(b.stm) { return -30000; } else { return 0; }
    }

    let mut value = i16::MIN/2;
    let mut best = Move::default();
        let mut alpha = prev_score.saturating_sub(50);
        let mut beta = prev_score.saturating_add(50);
        let original_alpha = alpha; let original_beta = beta;
    for mv in moves {
        let mut bb = b.clone();
        let _u = bb.make_move(mv);
        let sc = -alphabeta_mt(&bb, depth-1, -beta, -alpha, tt.clone());
        if sc > value { value = sc; best = mv; }
        if value > alpha { alpha = value; }
        if alpha >= beta { break; }
    }
    let bound = if value <= alpha { Bound::Upper }
                else if value >= beta { Bound::Lower }
                else { Bound::Exact };
    tt.lock().store(Entry { key: b.key, depth: depth as i8, value, best, bound });
    value
}

#[allow(dead_code)]
fn qsearch_mt(b:&Board, mut alpha:i16, beta:i16, tt: Arc<Mutex<TT>>) -> i16 {
    let stand = eval(b);
    if stand >= beta { return beta; }
    if stand > alpha { alpha = stand; }

    let moves = legal_moves(b);
    for mv in moves {
        let mut bb = b.clone();
        if bb.piece_at(mv.to).is_none() { continue; }
        let _u = bb.make_move(mv);
        let score = -qsearch_mt(&bb, -beta, -alpha, tt.clone());
        if score >= beta { return beta; }
        if score > alpha { alpha = score; }
    }
    alpha
}

// PST-based eval with tunable piece values and PST scales + eval pack
fn eval(b:&Board) -> i16 {
    // PSTs from white's perspective
    const PAWN: [i16;64] = [
         0,  5,  5, -5, -5,  5,  5,  0,
         0, 10, -5,  0,  0, -5, 10,  0,
         0, 10, 10, 20, 20, 10, 10,  0,
         5, 10, 20, 35, 35, 20, 10,  5,
        10, 20, 30, 40, 40, 30, 20, 10,
        15, 25, 35, 45, 45, 35, 25, 15,
        20, 30, 30,  0,  0, 30, 30, 20,
         0,  0,  0,  0,  0,  0,  0,  0,
    ];
    const KNIGHT: [i16;64] = [
        -50,-30,-10,-10,-10,-10,-30,-50,
        -30, -5,  5, 10, 10,  5, -5,-30,
        -10, 10, 15, 20, 20, 15, 10,-10,
        -10,  5, 20, 25, 25, 20,  5,-10,
        -10,  5, 20, 25, 25, 20,  5,-10,
        -10, 10, 15, 20, 20, 15, 10,-10,
        -30, -5,  5, 10, 10,  5, -5,-30,
        -50,-30,-10,-10,-10,-10,-30,-50,
    ];
    const BISHOP: [i16;64] = [
        -20,-10,-10,-10,-10,-10,-10,-20,
        -10,  5,  0,  5,  5,  0,  5,-10,
        -10, 10, 10, 15, 15, 10, 10,-10,
        -10, 10, 15, 20, 20, 15, 10,-10,
        -10, 10, 15, 20, 20, 15, 10,-10,
        -10, 10, 10, 15, 15, 10, 10,-10,
        -10,  5,  0,  5,  5,  0,  5,-10,
        -20,-10,-10,-10,-10,-10,-10,-20,
    ];
    const ROOK: [i16;64] = [
          0,  0,  5, 10, 10,  5,  0,  0,
          0,  0,  5, 10, 10,  5,  0,  0,
          0,  0,  5, 10, 10,  5,  0,  0,
          5, 10, 10, 15, 15, 10, 10,  5,
          5, 10, 10, 15, 15, 10, 10,  5,
          0,  0,  5, 10, 10,  5,  0,  0,
          0,  0,  5, 10, 10,  5,  0,  0,
          0,  0,  5, 10, 10,  5,  0,  0,
    ];
    const QUEEN: [i16;64] = [
        -20,-10,-10, -5, -5,-10,-10,-20,
        -10,  0,  0,  0,  0,  0,  0,-10,
        -10,  0,  5,  5,  5,  5,  0,-10,
         -5,  0,  5, 10, 10,  5,  0, -5,
         -5,  0,  5, 10, 10,  5,  0, -5,
        -10,  0,  5,  5,  5,  5,  0,-10,
        -10,  0,  0,  0,  0,  0,  0,-10,
        -20,-10,-10, -5, -5,-10,-10,-20,
    ];
    const KING: [i16;64] = [
        -30,-40,-40,-50,-50,-40,-40,-30,
        -30,-40,-40,-50,-50,-40,-40,-30,
        -30,-40,-40,-50,-50,-40,-40,-30,
        -30,-30,-30,-40,-40,-30,-30,-30,
        -20,-20,-20,-20,-20,-20,-20,-20,
        -10,-10,-10,-10,-10,-10,-10,-10,
         20, 20,  0,  0,  0,  0, 20, 20,
         20, 30, 10,  0,  0, 10, 30, 20,
    ];

    let p = PARAMS.read();
    let pv = p.piece_val;

    // Material + PST
    let mut s: i32 = 0;
    let mut bishops = [0u8;2];
    let mut pawns_by_file = [[0u8;8];2];
    let mut king_sq = [None::<u8>;2];
    for i in 0..64u8 {
        if let Some(pc)=b.piece_at(i) {
            let side_idx = if matches!(pc.side, crate::types::Side::White) {0} else {1};
            if matches!(pc.kind, crate::types::PieceKind::Bishop) { bishops[side_idx]+=1; }
            if matches!(pc.kind, crate::types::PieceKind::Pawn) { pawns_by_file[side_idx][file_of(i)] += 1; }
            if matches!(pc.kind, crate::types::PieceKind::King) { king_sq[side_idx] = Some(i); }

            let idx_white = i as usize;
            let idx_black = (63 - i) as usize;
            let (pst, scale) = match pc.kind {
                crate::types::PieceKind::Pawn=>(&PAWN, p.pst_scale[0]), crate::types::PieceKind::Knight=>(&KNIGHT, p.pst_scale[1]), crate::types::PieceKind::Bishop=>(&BISHOP, p.pst_scale[2]),
                crate::types::PieceKind::Rook=>(&ROOK, p.pst_scale[3]), crate::types::PieceKind::Queen=>(&QUEEN, p.pst_scale[4]), crate::types::PieceKind::King=>(&KING, p.pst_scale[5]),
            };
            let pst_score = if pc.side==crate::types::Side::White { pst[idx_white] } else { pst[idx_black] };
            let pst_scaled = (pst_score as f32 * scale) as i16;
            let val = match pc.kind {
                crate::types::PieceKind::Pawn=>pv[0] as i32, crate::types::PieceKind::Knight=>pv[1] as i32, crate::types::PieceKind::Bishop=>pv[2] as i32,
                crate::types::PieceKind::Rook=>pv[3] as i32, crate::types::PieceKind::Queen=>pv[4] as i32, crate::types::PieceKind::King=>pv[5] as i32,
            };
            let term = (val as i16 + pst_scaled) as i32;
            s += if pc.side==crate::types::Side::White { term } else { -term };
        }
    }

    // Bishop pair
    if bishops[0] >= 2 { s += p.bishop_pair as i32; }
    if bishops[1] >= 2 { s -= p.bishop_pair as i32; }

    // Rook on open / semi-open files
    for i in 0..64u8 {
        if let Some(pc)=b.piece_at(i) {
            if matches!(pc.kind, crate::types::PieceKind::Rook) {
                let side_idx = if pc.side==crate::types::Side::White {0} else {1};
                let f = file_of(i);
                let friendly_pawns = pawns_by_file[side_idx][f];
                let enemy_pawns = pawns_by_file[1-side_idx][f];
                if friendly_pawns==0 && enemy_pawns==0 {
                    s += if side_idx==0 { p.rook_open_file as i32 } else { -(p.rook_open_file as i32) };
                } else if friendly_pawns==0 && enemy_pawns>0 {
                    s += if side_idx==0 { p.rook_semi_open_file as i32 } else { -(p.rook_semi_open_file as i32) };
                }
            }
        }
    }

    // Pawn structure: isolated, doubled, passed (rank-based)
    for side_idx in 0..2 {
        let sign = if side_idx==0 { 1 } else { -1 };
        // doubled
        for f in 0..8 {
            if pawns_by_file[side_idx][f] > 1 {
                let extra = (pawns_by_file[side_idx][f] - 1) as i32;
                s += sign * extra * (p.doubled_pawn as i32);
            }
        }
        // isolated & passed per pawn
        for i in 0..64u8 {
            if let Some(pc)=b.piece_at(i) {
                if (side_idx==0 && pc.side==crate::types::Side::White) || (side_idx==1 && pc.side==crate::types::Side::Black) {
                    if matches!(pc.kind, crate::types::PieceKind::Pawn) {
                        let f = file_of(i) as i32;
                        let r = rank_of(i) as i32;
                        // isolated
                        let left = if f>0 { pawns_by_file[side_idx][(f-1) as usize] } else { 0 };
                        let right = if f<7 { pawns_by_file[side_idx][(f+1) as usize] } else { 0 };
                        if left==0 && right==0 { s += sign * (p.isolated_pawn as i32); }

                        // passed: scan enemy pawns
                        let mut enemy_block = false;
                        for sq in 0..64u8 {
                            if let Some(ep)=b.piece_at(sq) {
                                if ep.side != (if side_idx==0 {crate::types::Side::Black} else {crate::types::Side::White}) { continue; }
                                if !matches!(ep.kind, crate::types::PieceKind::Pawn) { continue; }
                                let ef = file_of(sq) as i32;
                                let er = rank_of(sq) as i32;
                                if (ef - f).abs() <= 1 {
                                    if side_idx==0 { if er > r { enemy_block = true; } }
                                    else { if er < r { enemy_block = true; } }
                                }
                            }
                        }
                        if !enemy_block {
                            let rel_rank = if side_idx==0 { r } else { 7 - r };
                            let idx = rel_rank.clamp(0,7) as usize;
                            s += sign * (p.passed_pawn[idx] as i32);
                        }
                    }
                }
            }
        }
    }

    // King pawn shield (front three squares one rank ahead)
    for side_idx in 0..2 {
        if let Some(ksq)=king_sq[side_idx] {
            let kf = file_of(ksq) as i32;
            let kr = rank_of(ksq) as i32;
            let target_rank = kr + if side_idx==0 { 1 } else { -1 };
            if target_rank >= 0 && target_rank <= 7 {
                let mut missing = 0i32;
                for df in -1..=1 {
                    let nf = kf + df;
                    if nf < 0 || nf > 7 { continue; }
                    let idx = (target_rank*8 + nf) as usize;
                    let pawn_here = match b.pieces[idx] {
                        Some(pc) => matches!(pc.kind, crate::types::PieceKind::Pawn) && ((side_idx==0 && pc.side==crate::types::Side::White) || (side_idx==1 && pc.side==crate::types::Side::Black)),
                        None => false
                    };
                    if !pawn_here { missing += 1; }
                }
                s += if side_idx==0 { (p.king_shield_missing as i32) * missing } else { -(p.king_shield_missing as i32) * missing };
            }
        }
    }

    let out = if b.stm==crate::types::Side::White { s } else { -s };
    out as i16
}


fn see(b: &Board, from: u8, to: u8) -> i32 {
    let val = |k: crate::types::PieceKind| -> i32 {
        match k { Pawn=>100, Knight=>320, Bishop=>330, Rook=>500, Queen=>900, King=>10_000 }
    };
    let mut occ = b.pieces;
    let mut side = b.stm;
    let mut gain = [0i32; 32];
    let mut depth = 0usize;

    let Some(mut victim) = b.piece_at(to) else { return 0; };

    let mut from_sq = from as usize;
    gain[depth] = val(victim.kind);

    loop {
        depth += 1;
        let attacker = occ[from_sq].unwrap();
        occ[to as usize] = Some(attacker);
        occ[from_sq] = None;

        side = side.flip();

        let mut best_from: Option<usize> = None;
        let mut best_kind_val = i32::MAX;

        for sq in 0..64usize {
            if let Some(p)=occ[sq] {
                if p.side != side { continue; }
                let f = (sq as u8 % 8) as i32;
                let r = (sq as u8 / 8) as i32;
                let tf = (to % 8) as i32;
                let tr = (to / 8) as i32;
                let df = tf - f;
                let dr = tr - r;

                let attacks = match p.kind {
                    Pawn => {
                        let dir = if p.side==crate::types::Side::White { 1 } else { -1 };
                        (dr == dir) && (df.abs() == 1)
                    },
                    Knight => {
                        (df.abs()==1 && dr.abs()==2) || (df.abs()==2 && dr.abs()==1)
                    },
                    Bishop => {
                        if df.abs()==dr.abs() { ray_clear(&occ, sq, to as usize, df.signum(), dr.signum()) } else { false }
                    },
                    Rook => {
                        if df==0 || dr==0 {
                            let sx = df.signum(); let sy = dr.signum();
                            ray_clear(&occ, sq, to as usize, sx, sy)
                        } else { false }
                    },
                    Queen => {
                        if df.abs()==dr.abs() || df==0 || dr==0 {
                            let sx = df.signum(); let sy = dr.signum();
                            ray_clear(&occ, sq, to as usize, sx, sy)
                        } else { false }
                    },
                    King => { df.abs()<=1 && dr.abs()<=1 }
                };
                if attacks {
                    let k = val(p.kind);
                    if k < best_kind_val {
                        best_kind_val = k;
                        best_from = Some(sq);
                    }
                }
            }
        }

        if best_from.is_none() { break; }
        from_sq = best_from.unwrap();
        victim = occ[to as usize].unwrap();
        gain[depth] = val(victim.kind) - gain[depth-1].max(0);
        if gain[depth] < 0 { break; }
    }

    let mut n = depth as i32;
    while n > 0 {
        gain[(n-1) as usize] = -gain[(n-1) as usize].max(-gain[n as usize]);
        n -= 1;
    }
    gain[0]
}

fn ray_clear(occ: &[Option<crate::types::Piece>;64], from: usize, to: usize, sx: i32, sy: i32) -> bool {
    let mut f = (from as u8 % 8) as i32;
    let mut r = (from as u8 / 8) as i32;
    let tf = (to as u8 % 8) as i32;
    let tr = (to as u8 / 8) as i32;
    let mut cf = f + sx; let mut cr = r + sy;
    while cf != tf || cr != tr {
        let idx = (cr*8 + cf) as usize;
        if occ[idx].is_some() { return false; }
        cf += sx; cr += sy;
    }
    true
}
